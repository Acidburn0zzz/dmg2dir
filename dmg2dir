#!/bin/bash

if [[ $DEBUG == 1 ]]; then set -x; fi

args=$#
mediadir="/run/media/$USER"
tmpdir="/tmp/dmg2dir"
force=false
customname=false
color1="\033[32m==>\033[0;1m"
color2="\033[34m  ->\033[0m"
color3="\033[1;42m"
color4="\033[1;41m"
endcolor="\033[0m"
version="2.2.0"


usage() {
	if [[ $(locale -a | grep french) == "french" ]]; then
		echo "Usage :"
		echo -e "  $0 [OPTIONS] <fichierdmg>\t\t ou"
		echo -e "  $0 <fichierdmg> [OPTIONS]\t\t ou"
		echo "  $0 [OPTIONS] <fichierdmg> [OPTIONS]"
		echo "...où <fichierdmg> est un fichier dont l'extension est .dmg (conçu pour OS X)"
		echo -e "\nOptions :"
		echo -e "-n, --name\t Nom personnalisé du répertoire de l'application qui sera créé"
		echo -e "-p, --path\t Chemin personnalisé où le répertoire de l'application sera"
		echo -e "-t, --tmp\t Répertoire temporaire personnalisé"
		echo -e "-m, --media\t Répertoire où les médias sont montés automatiquement. Il n'est pas nécessaire de la changer"
		echo -e "-f, --force\t Force '$0' à écraser le fichier .img s'il existe"
		echo -e "-v, --verbose\t Sortie bavarde"
		echo -e "-vv, --vverbose\t Sortie très bavarde"
		echo -e "-V, --version\t Affiche la version du script et quitte"
		echo -e "-h, --help\t Affiche ce message et quitte"
		echo -e "-a, --about\t Affiche des informations diverses et quitte"
	else
		echo "Usage:"
		echo -e "  $0 [OPTIONS] <dmgfile>\t\t or"
		echo -e "  $0 <dmgfile> [OPTIONS]\t\t or"
		echo "  $0 [OPTIONS] <dmgfile> [OPTIONS]"
		echo "...where <dmgfile> is a file which extension is .dmg (designed for OS X)"
		echo -e "\nOptions:"
		echo -e "-n, --name\t Custom name for application directory which will be created"
		echo -e "-p, --path\t Custom path where application directory will be"
		echo -e "-t, --tmp\t Custom temporary directory"
		echo -e "-m, --media\t Directory where media are automatically mounted. You shouldn't change it"
		echo -e "-f, --force\t Force '$0' to overwrite .img file if it exists"
		echo -e "-v, --verbose\t Verbose output"
		echo -e "-vv, --vverbose\t Very verbose output"
		echo -e "-V, --version\t Display script version and exit"
		echo -e "-h, --help\t Display this message and exit"
		echo -e "-a, --about\t Display various informations and exit"
	fi
}

about() {
	if [[ $(locale -a | grep french) == "french" ]]; then
		echo -e "$0 est un script shell qui extrait les applications OS X depuis un fichier .dmg.\n"
		echo "Les variables du script sont :"
		echo "  args : nombre d'arguments utilisés en entrée : $args"
		echo "  mediadir : le répertoire où les médias sont montés automatiquement : $mediadir"
		echo "  tmpdir : le répertoire temporaire : $tmpdir"
		echo "  force : sa valeur est true quand -f ou --force est utilisé : $force"
		echo "  customname : sa valeur est true quand -n ou --name est utilisé : $customname"
		echo -e "\nPour utiliser le mode de débuguage, utilisez la commande : 'DEBUG=1 $0'"
	else
		echo -e "$0 is a shell script which extract OS X application from .dmg file.\n"
		echo "Script's variables are:"
		echo "  args: number of arguments used in input: $args"
		echo "  mediadir: directory where media are automatically mounted: $mediadir"
		echo "  tmpdir: temporary directory: $tmpdir"
		echo "  force: value is true when -f or --force is used: $force"
		echo "  customname: value is true when -n or --name is used: $customname"
		echo -e "\nTo use debug mode, use command : 'DEBUG=1 $0'"
	fi
}

version() {
	if [[ $(locale -a | grep french) == "french" ]]; then
		echo -e "\n$0. Version $version. Écrit par X0rg.\n"
	else
		echo -e "\n$0. Version $version. Written by X0rg.\n"
	fi
}



error() {
	if [[ $(locale -a | grep french) == "french" ]]; then
	echo -e "\033[31mErreur $1.\033[0m"
	else
	echo -e "\033[31mError $1.\033[0m"
	fi

	exit $1
}

trackerror() {
	if [[ $output == ERROR* ]]; then
		error $1
	elif [[ -z $2 ]]; then
		error $1
	fi
}

convertdmg() {
	if [ ! -e $tmpdir/$name.img ] || $force ; then

		if [ ! -z "$v" ]; then
			verbose msg110 ; output=$(dmg2img $v -i $filetoconvert -o $tmpdir/$name.img)
			echo $output
			trackerror 10 0
		else
			output=$(dmg2img -s -i $filetoconvert -o $tmpdir/$name.img)
			trackerror 11 0
		fi

	fi
}

premount() {
	verbose msg210 ; loop=$(udisksctl loop-setup -f $tmpdir/$name.img) || error 20
	verbose msg215 ; size=$(expr length "$loop") ; trackerror 26 $size
	verbose msg220 ; cut_end=$((size-1)) ; trackerror 28 $cut_end
	verbose msg225 ; cut_start=$((cut_end-9)) ; trackerror 30 $cut_start

	verbose msg230 ; loop=$(echo $loop | cut -c$cut_start-$cut_end)

	verbose msg240 ; loop_p=$(fdisk -s $loop* | grep $loop\p | grep -Evw \
		"1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31|32|33|34|35"\
		| cut -c1-12) ; trackerror 40 $loop_p

	verbose msg250 ; label=$(udisksctl info -b $loop_p | grep IdLabel | cut -c33-) ; trackerror 50 $label
	
	if ! $customname; then
		verbose msg260 ; name=$label
		trackerror 55 $name
	fi
}

mountimg() {
	if [ ! -z "$v" -o ! -z "$vv" ]; then
		verbose msg310 ; udisksctl mount -b $loop_p || error 60
	else
		udisksctl mount -b $loop_p &> /dev/null || error 61
	fi
}

copy() {
	if [[ ! -z $savepath ]]; then
		verbose msg410 ; app_directory="$savepath/$name"
	else
		verbose msg415 ; app_directory=$(dirname "$filetoconvert")/"$name"
	fi

	verbose msg420 ; mkdir -p $v "$app_directory" || error 75
	verbose msg430 ; cp -aup $v "$mediadir/$label"*/* "$app_directory" || error 80
}

umountimg() {
	if [ ! -z "$v" ]; then
		verbose msg510 ; udisksctl unmount -b $loop_p || error 90
	else
		udisksctl unmount -b $loop_p &> /dev/null || error 91
	fi

	verbose msg520 ; udisksctl loop-delete -b $loop || error 100
}

verbose() {
	if [ ! -z $v ]; then

		if [[ $(locale -a | grep french) == "french" ]]; then
			msg0="\n$color1 Créé le dossier temporaire de travail...$endcolor"
			msg100="\n$color1 Convertit le fichier DMG en un fichier IMG ...$endcolor"
			msg200="\n$color1 Prépare le périphérique loop...$endcolor" 
			msg300="\n$color1 Monte le périphérique loop...$endcolor"
			msg400="\n$color1 Copie les fichiers...$endcolor"
			msg500="\n$color1 Démonte le périphérique loop...$endcolor"
			msg600="\n$color3$label a été extrait dans $app_directory.$endcolor"
			msg610="\n$color4$app_directory est vide !$endcolor"
		else
			msg0="\n$color1 Make temporary working directory...$endcolor"
			msg100="\n$color1 Convert DMG file to IMG file...$endcolor"
			msg200="\n$color1 Prepare loop device...$endcolor"
			msg300="\n$color1 Mount loop device...$endcolor"
			msg400="\n$color1 Copy files...$endcolor"
			msg500="\n$color1 Umount loop device...$endcolor"
			msg600="\n$color3$label has been extracted in $app_directory.$endcolor"
			msg610="\n$color4$app_directory is empty!$endcolor"
		fi

	fi

	if [[ ! -z $vv ]]; then

		if [[ $(locale -a | grep french) == "french" ]]; then
			msg110="$color2 Convertit $filetoconvert en $tmpdir/$name.img"
			msg210="$color2 Configure le périphérique loop depuis le fichier $tmpdir/$name.img"
			msg215="$color2 Détermine la taille de la variable \$loop"
			msg220="$color2 Détermine la fin où on coupera dans \$cut_end"
			msg225="$color2 Détermine le début où on coupera dans \$cut_start"
			msg230="$color2 Découpe la variable \$loop pour qu'elle contienne le périphérique loop"
			msg240="$color2 Cherche quelle est la meilleur partition loop"
			msg250="$color2 Cherche le nom de la partition"
			msg260="$color2 Pas de nom personnalisé définit. Utilisera \$label $label comme \$name"
			msg310="$color2 Monte $loop_p'"
			msg410="$color2 L'option --path est utilisée. Configure la variable \$app_directory comme : $savepath/$name"
			msg415="$color2 Configure la variable \$app_directory"
			msg420="$color2 Créé le répertoire $app_directory"
			msg430="$color2 Copie les fichiers de $mediadir/$label dans $app_directory"
			msg510="$color2 Démonte $loop_p"
			msg520="$color2 Supprime le périphérique loop $loop"
		else
			msg110="$color2 Convert $filetoconvert to $tmpdir/$name.img"
			msg210="$color2 Set-up loop device from file $tmpdir/$name.img"
			msg215="$color2 Determine length of variable \$loop"
			msg220="$color2 Determine end where we will cut in \$cut_end"
			msg225="$color2 Determine start where we will cut in \$cut_start"
			msg230="$color2 Cut variable \$loop to contain loop device"
			msg240="$color2 Find what is the best loop partition"
			msg250="$color2 Find partition label"
			msg260="$color2 No custom name set. Will use \$label $label at \$name"
			msg310="$color2 Mount $loop_p'"
			msg410="$color2 Option --path is used. Set variable \$app_directory as : $savepath/$name"
			msg415="$color2 Set variable \$app_directory"
			msg420="$color2 Make directory $app_directory"
			msg430="$color2 Copy files from $mediadir/$label into $app_directory"
			msg510="$color2 Unmount $loop_p"
			msg520="$color2 Delete loop device $loop"
		fi

	fi

	eval msg='$'$1
	if [[ ! -z $msg ]]; then echo -e "$msg"; fi
}


while test $# -gt 0
do
	option=$1

	case "$option" in
		-n|--name)	name="$2";customname=true; shift;;
		-p|--path)	savepath="$2"; shift;;
		-t|--tmp)	tmpdir="$2"; shift;;
		-m|--media)	mediadir="$2"; shift;;
		-f|--force)	force=true;;
		-v|--verbose)	v="-v";;
	       -vv|--vverbose)	v="-v"; vv="veeeeery veeeeerbose";;
		-V|--version)	version; exit 0;;
		-h|--help)	usage; exit 0;;
		-a|--about)	about; exit 0;;
		- |--)		usage; exit 1;;
		*)		filetoconvert=$1;;
	esac
	shift
done


if [[ $args == 0 && -z $name ]]; then
	usage
	exit 2
fi


if [ -z $name ]; then
	name=$(basename "$filetoconvert" .dmg)
fi

verbose msg0   ; mkdir -p $v $tmpdir
verbose msg100 ; convertdmg
verbose msg200 ; premount
verbose msg300 ; mountimg
verbose msg400 ; copy
verbose msg500 ; umountimg

if [[ -s $app_directory ]]; then
	verbose msg600
else
	verbose msg610
	error 110
fi

if [[ $DEBUG == 1 ]]; then set +x; fi

exit 0

# Written by Xorg (https://github.com/X0rg?tab=repositories). Version 2.2.0. Copyleft 2013.